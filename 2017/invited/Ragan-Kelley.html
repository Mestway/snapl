<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="description" content="Summit oN Advances in Programming Languages" />
	<meta name="keywords" content="SNAPL 2017" />
	<meta name="author" content="Phitchaya Mangpo Phothilimthana" />
	<link href='http://fonts.googleapis.com/css?family=Dosis' rel='stylesheet' type='text/css' />
	<link rel="stylesheet" type="text/css" href="../origo.css" title="Origo" media="all" />
	<title>SNAPL 2017</title>
</head>

<body class="light blue smaller freestyle01">
<div id="layout">
 
	<div class="row smaller">
		<div class="col smaller">
			<h1><a href="../index.html">SNAPL 2017</a></h1>
		</div>
		
		<div class="col c7 alignright">
			<p class="slogan">May 7-10, 2017 <span style="padding-left:30px">  Asilomar, California</p>
		</div>
	</div>
  
	<div class="row">
		<div class="col aligncenter">
			<img src="../images/monterey.png" alt="" width="760"/>
		</div>
	</div>
 
	<div class="row">

    		<div class="col c9">

                      <h2>Programming systems should treat the organization of computation as a first-class concern</h2>

                      <h4>Jonathan Ragan-Kelley</h4>

<p>
We live in the twilight of Moore’s Law. From data centers to mobile devices, performance and energy scaling is limited by locality (the distance over which data has to move, e.g., from nearby caches, far away main memory, or across networks) and parallelism. Because of this, I argue that we should think of the performance and efficiency of an application as determined not just by the algorithm and the hardware on which it runs, but critically also by the organization of computations and data. For algorithms with the same complexity—even the exact same set of arithmetic operations and data—executing on the same hardware, with the same level of tuning in their innermost loop, the order and granularity of execution and placement of data can easily change performance by an order of magnitude because of locality and parallelism.
<br><br>
To extract the full potential of our machines—indeed, to scale at all beyond the performance we have today—we need to treat the organization of computation as a first class concern in our applications, and therefore also in the languages and tools with which we build them. In this talk, I will give a taste of how this philosophy appears in the Halide language and its concept of “schedules,” point out some successes and challenges with this specific design, and suggest ways the organization of computation could be exposed and exploited more broadly.
</p>
    		</div>

	</div>
 
	<div id="footer" class="row">
		<div class="col c12 aligncenter">
			<h3>&copy; 2017 SNAPL Conference</h3>
			<p><a href="http://andreasviklund.com/templates/origo/">Template design</a> by <a href="http://andreasviklund.com/">Andreas Viklund</a><br>Header picture by Phitchaya Mangpo Phothilimthana</p>
		</div>
	</div>
 </div>
</body>
</html>

